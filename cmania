#!/usr/bin/python3

import curses
from curses import wrapper
import time
import pyaudio
import wave
import time
import sys
import threading
import queue
import play
from random import randint

HEIGHT = 40
WIDTH = 80
KEY_DELAY = 6
SPACING = 13
BUMPERS_INDEX = 16

keys = []
noteStream = queue.Queue()
keyDown = -1

def playWAVFile(filename):
    wf = wave.open(filename, 'rb')

    p = pyaudio.PyAudio()

    def callback(in_data, frame_count, time_info, status):
        data = wf.readframes(frame_count)
        return (data, pyaudio.paContinue)

    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
                    channels=wf.getnchannels(),
                    rate=wf.getframerate(),
                    output=True,
                    stream_callback=callback)

    stream.start_stream()

    while stream.is_active():
        time.sleep(0.1)

    stream.stop_stream()
    stream.close()
    wf.close()

    p.terminate()

def renderBorder(stdscr):
    borderChar = " "
    for i in range(0,WIDTH-1):
        stdscr.addstr(0, i, borderChar, curses.A_REVERSE)
        stdscr.addstr(HEIGHT-1, i, borderChar, curses.A_REVERSE)
    for i in range(1,HEIGHT-1):
        stdscr.addstr(i, 0, borderChar, curses.A_REVERSE)
        stdscr.addstr(i, WIDTH-2, borderChar, curses.A_REVERSE)

def renderBumpers(stdscr, colorcode):
    start = 3
    for i in range(4):
        for j in range(5):
            if j == 2:
                stdscr.addstr(HEIGHT-start-j, BUMPERS_INDEX+i*SPACING, "+")
                stdscr.addstr(HEIGHT-start-j, BUMPERS_INDEX+i*SPACING+5, "+")
            else:
                stdscr.addstr(HEIGHT-start-j, BUMPERS_INDEX+i*SPACING, "|")
                stdscr.addstr(HEIGHT-start-j, BUMPERS_INDEX+i*SPACING+5, "|")
            if colorcode[i]:
                stdscr.addstr(HEIGHT-start-j, BUMPERS_INDEX+i*SPACING+1, "    ", curses.color_pair(colorcode[i]))
             
def pushNote(note):
    noteStream.put(note)

def addNote(index):
    keys.append([index, 1])

def main(stdscr):
    curses.start_color()

    curses.resizeterm(HEIGHT, WIDTH)

    curses.curs_set(0)
    stdscr.clear()
    stdscr.nodelay(1)

    curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_RED)
    curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_GREEN)

    keys.append([2,1])
    keyDelay = KEY_DELAY
    
    play.start_song(sys.argv[1], (HEIGHT-5.0) / 30.0, pushNote)
    while 1:
        time.sleep(1/30.0)

        colorcode = [0, 0, 0, 0]
        
        if not noteStream.empty():
            addNote(noteStream.get())

        keyNum = stdscr.getch()
        stdscr.clear()
        
        if keyNum == -1 and keyDelay > 0:
            keyDelay -= 1
            keyNum = keyPrev
        elif keyNum == ord('d'):
            keyDelay = KEY_DELAY
            keyNum = 0
        elif keyNum == ord('f'):
            keyDelay = KEY_DELAY
            keyNum = 1
        elif keyNum == ord('j'):
            keyDelay = KEY_DELAY
            keyNum = 2
        elif keyNum == ord('k'):
            keyDelay = KEY_DELAY
            keyNum = 3
        if keyNum == ord('q'):
            break
        
        keyPrev = keyNum
        
        stdscr.addstr(2, 2, str(keyNum))
        
        for key in keys:
            key[1] += 1
            if key[1] >= HEIGHT-1:
                keys[0] = -1
                colorcode[key[0]] = 1
            elif key[1] < HEIGHT-1 and key[1] > HEIGHT-8:
                if keyNum == key[0]:
                    keys[0] = -1
                    colorcode[key[0]] = 2
                else:
                    stdscr.addstr(int(key[1]), key[0]*SPACING + BUMPERS_INDEX, " ++++ ")
            else:
                stdscr.addstr(int(key[1]), key[0]*SPACING + BUMPERS_INDEX, " ++++ ")

        for key in keys:
            if keys[0] == -1:
                keys.remove(key)

        renderBumpers(stdscr, colorcode)
        renderBorder(stdscr)

        stdscr.refresh()

    
wrapper(main)
